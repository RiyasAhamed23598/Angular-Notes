## Content projection with ng-content

```
<ng-content select="h3"></ng-content>    // works like query selector

<ng-content select=".remember"></ng-content>    // bind by class

```

- get access to the projected content:

```
@ViewChild('email') email: ElementRef;

@ViewChild(AuthMessageComponent) message: AuthMessageComponent;
@ViewChildren(AuthMessageComponent) remember: QueryList<AuthMessageComponent>;

@ContentChild(AuthRememberComponent) remember: AuthRememberComponent;
@ContentChildren(AuthRememberComponent) rememberList: QueryList<AuthRememberComponent>;

constructor(private _cd: ChangeDetectorRef) {}

ngAfterViewInit() {
  this.email.nativeElement.setAttribute('placeholder', 'enter your email address');
  
  if (this.message) {
    this.message.forEach((message) => {  
      message.days = 30;
    }
  }
  this._cd.detectChanges();
}

ngAfterContentInit() {
  if (this.remember){
    this.remember.checked.subscribe((checked: boolean) => {
      this.showMessage = checked;
    });
  }
  
  if (this.rememberList){
    this.remember.forEach((item) => {
      item.checked.subscribe((checked: boolean) => {
        this.showMessage = checked;
      });
    }
  }
}
```

## using Renderer

Renderer is **plaform agnostic**. You can use the same code on web and mobile.

```
constructor(private _renderer: Renderer) {}

ngAfterViewInit() {
  this.renderer.setElementAttribute(this.email.nativeElement, 'placeholder', 'enter your email address');
}
```

## Dynamic components with ComponentFactoryResolver // deprecated

```
@ViewChild('entry', {read: ViewContainerRef }) entry: ViewContainerRef;

constructor(private resolver: ComponentFactoryResolver) {
}

ngAfterContentInit() {
  const authFormFactory = this.resolver.resolveComponentFactory(AuthFormComponent);
  const component = this.entry.createComponent(authFormFactory)
}

```
Using this approach you need to add AuthFormComponent to entryComponents array


